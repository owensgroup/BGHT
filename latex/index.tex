\label{index_md_README}%
\Hypertarget{index_md_README}%
 $\vert$ \href{https://owensgroup.github.io/BGHT/}{\texttt{ {\bfseries{Documentation}}}} $\vert$ \href{https://github.com/owensgroup/BGHT/tree/main/test}{\texttt{ {\bfseries{Examples/\+Tests}}}} $\vert$ \href{https://github.com/owensgroup/BGHT/tree/main/benchmarks}{\texttt{ {\bfseries{Benchmarks}}}} $\vert$ \href{https://github.com/owensgroup/BGHT/blob/main/results.md}{\texttt{ {\bfseries{Results}}}} $\vert$ $\vert$-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---$\vert$-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---$\vert$-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---$\vert$-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---$\vert$

BGHT is a collection of high-\/performance static GPU hash tables. BGHT contains hash tables that use three different probing schemes 1) bucketed cuckoo, 2) power-\/of-\/two, 3) iceberg hashing. Our bucketed static cuckoo hash table is the state-\/of-\/art static hash table. For more information, please check our paper\+:

\href{https://arxiv.org/abs/2108.07232}{\texttt{ {\bfseries{Better GPU Hash Tables}}}}~\newline
 {\itshape \href{https://maawad.github.io/}{\texttt{ Muhammad A. Awad}}, \href{https://scholar.google.com/citations?user=Z4_ZfiEAAAAJ&hl=en}{\texttt{ Saman Ashkiani}}, \href{https://web.cs.ucdavis.edu/~porumbes/}{\texttt{ Serban D. Porumbescu}}, \href{https://people.cs.rutgers.edu/~farach/}{\texttt{ Mart√≠n Farach-\/\+Colton}}, and \href{https://www.ece.ucdavis.edu/~jowens/}{\texttt{ John D. Owens}}}\hypertarget{index_autotoc_md1}{}\doxysection{Key features}\label{index_autotoc_md1}

\begin{DoxyItemize}
\item State-\/of-\/the-\/art static GPU hash tables
\item Device and host side APIs
\item Support for different types of keys and values
\item Standard-\/like APIs
\end{DoxyItemize}\hypertarget{index_autotoc_md2}{}\doxysection{How to use}\label{index_autotoc_md2}
BGHT is a header-\/only library. To use the library, you can add it as a submodule or use \href{https://github.com/cpm-cmake/CPM.cmake}{\texttt{ CMake Package Manager (CPM)}} to fetch the library into your CMake-\/based project (\href{https://github.com/owensgroup/BGHT/tree/main/test/cpm}{\texttt{ complete example}}). 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake\_minimum\_required(VERSION 3.8 FATAL\_ERROR)}
\DoxyCodeLine{CPMAddPackage(}
\DoxyCodeLine{  NAME bght}
\DoxyCodeLine{  GITHUB\_REPOSITORY owensgroup/BGHT}
\DoxyCodeLine{  GIT\_TAG main}
\DoxyCodeLine{  OPTIONS}
\DoxyCodeLine{     "{}build\_tests OFF"{}}
\DoxyCodeLine{     "{}build\_benchmarks OFF"{}}
\DoxyCodeLine{)}
\DoxyCodeLine{target\_link\_libraries(my\_library PRIVATE bght)}

\end{DoxyCode}
\hypertarget{index_autotoc_md3}{}\doxysubsection{APIs}\label{index_autotoc_md3}
All the data structures follow the C++ standard hash map ({\ttfamily std\+::unordered\+\_\+map}) APIs closely. An example APIs for BCHT is shown below\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{template <class Key,}
\DoxyCodeLine{          class T,}
\DoxyCodeLine{          class Hash = bght::universal\_hash<Key>,}
\DoxyCodeLine{          class KeyEqual = bght::equal\_to<Key>,}
\DoxyCodeLine{          cuda::thread\_scope Scope = cuda::thread\_scope\_device,}
\DoxyCodeLine{          class Allocator = bght::cuda\_allocator<char>,}
\DoxyCodeLine{          int B = 16> class bcht;}

\end{DoxyCode}
 \hypertarget{index_autotoc_md4}{}\doxysubsubsection{Member functions}\label{index_autotoc_md4}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{// Constructor}
\DoxyCodeLine{bcht(std::size\_t capacity,}
\DoxyCodeLine{     Key sentinel\_key,}
\DoxyCodeLine{     T sentinel\_value,}
\DoxyCodeLine{     Allocator const\& allocator = Allocator\{\});}
\DoxyCodeLine{// Host-\/side APIs}
\DoxyCodeLine{template <typename InputIt>}
\DoxyCodeLine{  bool insert(InputIt first, InputIt last, cudaStream\_t stream = 0);}
\DoxyCodeLine{template <typename InputIt, typename OutputIt>}
\DoxyCodeLine{  void find(InputIt first, InputIt last, OutputIt output\_begin, cudaStream\_t stream = 0);}
\DoxyCodeLine{// Device-\/side APIs}
\DoxyCodeLine{template <typename tile\_type>}
\DoxyCodeLine{\_\_device\_\_ bool insert(value\_type const\& pair, tile\_type const\& tile);}
\DoxyCodeLine{template <typename tile\_type>}
\DoxyCodeLine{\_\_device\_\_ mapped\_type find(key\_type const\& key, tile\_type const\& tile);}

\end{DoxyCode}
 \hypertarget{index_autotoc_md5}{}\doxysubsection{Member types}\label{index_autotoc_md5}

\begin{DoxyCode}{0}
\DoxyCodeLine{Member type                     Definition}
\DoxyCodeLine{key\_type                        Key}
\DoxyCodeLine{mapped\_type                     T}
\DoxyCodeLine{value\_type                      bght::pair<Key, T>}
\DoxyCodeLine{allocator\_type                  Allocator}
\DoxyCodeLine{bucket\_size                     Bucket size for device-\/side APIs cooperative groups tile construction}

\end{DoxyCode}
\hypertarget{index_autotoc_md6}{}\doxysubsubsection{Example}\label{index_autotoc_md6}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{// Example using host-\/side APIs}
\DoxyCodeLine{\#include <bcht.hpp>}
\DoxyCodeLine{int main()\{}
\DoxyCodeLine{  using key\_type = uint32\_t;}
\DoxyCodeLine{  using value\_type = uint32\_t;}
\DoxyCodeLine{  using pair\_type = bght::pair<key\_type, value\_type>;}
\DoxyCodeLine{  std::size\_t capacity = 128; std::size\_t num\_keys = 64;}
\DoxyCodeLine{  key\_type invalid\_key = 0; value\_type invalid\_value = 0; // sentinel key and value}
\DoxyCodeLine{}
\DoxyCodeLine{  bght::bcht<key\_type, value\_type> table(capacity, invalid\_key, invalid\_value); //ctor}
\DoxyCodeLine{}
\DoxyCodeLine{  pair\_type* pairs; // input pairs}
\DoxyCodeLine{  // ... allocate pairs}
\DoxyCodeLine{}
\DoxyCodeLine{  bool success = table.insert(pairs, pairs + num\_keys);}
\DoxyCodeLine{  assert(success);}
\DoxyCodeLine{}
\DoxyCodeLine{  key\_type* queries;  // query keys}
\DoxyCodeLine{  value\_type* results; // query result}
\DoxyCodeLine{  // ... allocate queries and results}
\DoxyCodeLine{  table.find(queries, queries + num\_keys, results);}
\DoxyCodeLine{\}}

\end{DoxyCode}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{// Example using device-\/side APIs}
\DoxyCodeLine{template<class HashMap>}
\DoxyCodeLine{\_\_global\_\_ void kernel(HashMap table)\{}
\DoxyCodeLine{  // construct tile}
\DoxyCodeLine{  auto block = cooperative\_groups::this\_thread\_block();}
\DoxyCodeLine{  auto tile = cooperative\_groups::tiled\_partition<HashMap::bucket\_size>(block);}
\DoxyCodeLine{  pair\_type pair\{...\};}
\DoxyCodeLine{  table.insert(pair, tile);}
\DoxyCodeLine{  pair\_type query\{..\};}
\DoxyCodeLine{  query.second = table.find(query.first, tile);}
\DoxyCodeLine{\}}
\DoxyCodeLine{int main()\{}
\DoxyCodeLine{  // Call the hash table constructor on the CPU}
\DoxyCodeLine{  bght::bcht<key\_type, value\_type> table(...);}
\DoxyCodeLine{  // Pass the hash table to a GPU kernel}
\DoxyCodeLine{  kernel<<<...>>>(table);}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{index_autotoc_md7}{}\doxysection{Requirements and limitations}\label{index_autotoc_md7}
Please create an issue if you face challenges with any of the following limitations and requirements. \hypertarget{index_autotoc_md8}{}\doxysubsection{Requirements}\label{index_autotoc_md8}

\begin{DoxyItemize}
\item C++17/\+CUDA C++17
\item NVIDIA Volta GPU or later microarchitectures
\item CMake 3.\+8 or later
\item CUDA 11.\+5 or later
\end{DoxyItemize}\hypertarget{index_autotoc_md9}{}\doxysubsubsection{Using Docker}\label{index_autotoc_md9}
We provide a docker image that include the software requirements (except for CUDA drivers). To build the docker image, run\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{source docker/build}

\end{DoxyCode}
 To start the container, run\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{source docker/run}

\end{DoxyCode}
 After starting the container, you can build and execute BGHT code without any additional requirements.\hypertarget{index_autotoc_md10}{}\doxysubsection{limitations}\label{index_autotoc_md10}

\begin{DoxyItemize}
\item Currently hash tables based on cuckoo hashing do not support concurrent insertion and queries. IHT and P2\+BHT support concurrent insertions and queries.
\item Keys must be unique
\item Construction of the data structures offered {\itshape may} fail. In these scenarios, reconstructing the table using a larger capacity or a lower load factor should be considered. Our paper offers recommended hash table load factors (for uniformly distributed unsigned keys) to achieve at least a 99\% success rate (\href{https://arxiv.org/abs/2108.07232}{\texttt{ See Fig. 2}}). For example, BCHT will offer a 100\% success rate for up to 0.\+991 load factor. Please create an issue if you encounter any problems with different key distributions.
\end{DoxyItemize}\hypertarget{index_autotoc_md11}{}\doxysection{Reproducing the ar\+Xiv paper results}\label{index_autotoc_md11}
To reproduce the results, follow the following steps. You can also view our results here. If you find any mismatch (either faster or slower) between the results offered in the repository or the paper, please create an issue, and we will investigate the performance changes.\hypertarget{index_autotoc_md12}{}\doxysection{Benchmarks}\label{index_autotoc_md12}
Please check our \href{https://arxiv.org/abs/2108.07232}{\texttt{ paper}} for comprehensive analysis and benchmarks. Also, see the following steps to reproduce the results.

An additional comparison of our BCHT to {\ttfamily cuc\+Collection}\textquotesingle{}s {\ttfamily cuco\+::static\+\_\+map} is shown below. The comparison is between our BCHT with B = 16 (default configuration) and {\ttfamily cuco\+::static\+\_\+map}. Input keys (50 million pairs) are uniformly distributed unsigned keys. The benchmarking was performed on an NVIDIA Titan V GPU (higher is better)\+:

\hypertarget{index_autotoc_md13}{}\doxysection{Questions and bug report}\label{index_autotoc_md13}
Please create an issue. We will welcome any contributions that improve the usability and quality of our repository.\hypertarget{index_autotoc_md14}{}\doxysection{Bibtex}\label{index_autotoc_md14}

\begin{DoxyCode}{0}
\DoxyCodeLine{@inproceedings\{Awad:2023:AAI,}
\DoxyCodeLine{  title = \{Analyzing and Implementing \{GPU\} Hash Tables\},}
\DoxyCodeLine{  author = \{Muhammad A. Awad and Saman Ashkiani and Serban D.}
\DoxyCodeLine{                  Porumbescu and Mart\{\(\backslash\)'\{i\}\}n Farach-\/Colton and John}
\DoxyCodeLine{                  D. Owens\},}
\DoxyCodeLine{  booktitle = \{SIAM Symposium on Algorithmic Principles of Computer}
\DoxyCodeLine{                  Systems\},}
\DoxyCodeLine{  series = \{APOCS23\},}
\DoxyCodeLine{  year = 2023,}
\DoxyCodeLine{  month = jan,}
\DoxyCodeLine{  archiveprefix\_ = \{arXiv\},}
\DoxyCodeLine{  eprint\_ = \{2108.07232\},}
\DoxyCodeLine{  url = \{https://escholarship.org/uc/item/6cb1q6rz\}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{index_autotoc_md15}{}\doxysection{Acknowledgments}\label{index_autotoc_md15}
The structure and organization of the repository were inspired by \href{https://github.com/nviDIA/cuCollections/}{\texttt{ NVIDIA\textquotesingle{}s cu\+Collection}} and \href{https://github.com/owensgroup/RXMesh}{\texttt{ RXMesh}}. 