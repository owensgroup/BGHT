\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{\href{https://owensgroup.github.io/BGHT/}{\texttt{ Documentation}}}} }&\cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{\href{https://github.com/owensgroup/BGHT/tree/main/test}{\texttt{ Examples/\+Tests}}}} }&\cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{\href{https://github.com/owensgroup/BGHT/tree/main/benchmarks}{\texttt{ Benchmarks}}}} }&\cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{\href{https://github.com/owensgroup/BGHT/blob/main/results.md}{\texttt{ Results}}}} }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{\href{https://owensgroup.github.io/BGHT/}{\texttt{ Documentation}}}} }&\cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{\href{https://github.com/owensgroup/BGHT/tree/main/test}{\texttt{ Examples/\+Tests}}}} }&\cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{\href{https://github.com/owensgroup/BGHT/tree/main/benchmarks}{\texttt{ Benchmarks}}}} }&\cellcolor{\tableheadbgcolor}\textbf{ {\bfseries{\href{https://github.com/owensgroup/BGHT/blob/main/results.md}{\texttt{ Results}}}} }\\\cline{1-4}
\endhead
\end{longtabu}


B\+G\+HT is a collection of high-\/performance static G\+PU hash tables. B\+G\+HT contains hash tables that use three different probing schemes 1) bucketed cuckoo, 2) power-\/of-\/two, 3) iceberg hashing. Our bucketed static cuckoo hash table is the state-\/of-\/art static hash table. For more information, please check our paper\+:

\href{https://arxiv.org/abs/2108.07232}{\texttt{ {\bfseries{Better G\+PU Hash Tables}}}}~\newline
 {\itshape \href{https://maawad.github.io/}{\texttt{ Muhammad A. Awad}}, \href{https://scholar.google.com/citations?user=Z4_ZfiEAAAAJ&hl=en}{\texttt{ Saman Ashkiani}}, \href{https://web.cs.ucdavis.edu/~porumbes/}{\texttt{ Serban D. Porumbescu}}, \href{https://people.cs.rutgers.edu/~farach/}{\texttt{ Mart√≠n Farach-\/\+Colton}}, and \href{https://www.ece.ucdavis.edu/~jowens/}{\texttt{ John D. Owens}}}\hypertarget{index_autotoc_md1}{}\doxysection{Key features}\label{index_autotoc_md1}

\begin{DoxyItemize}
\item State-\/of-\/the-\/art static G\+PU hash tables
\item Device and host side A\+P\+Is
\item Support for different types of keys and values
\item Standard-\/like A\+P\+Is
\end{DoxyItemize}\hypertarget{index_autotoc_md2}{}\doxysection{How to use}\label{index_autotoc_md2}
B\+G\+HT is a header-\/only library. To use the library, you can add it as a submodule or use \href{https://github.com/cpm-cmake/CPM.cmake}{\texttt{ C\+Make Package Manager (C\+PM)}} to fetch the library into your C\+Make-\/based project (\href{https://github.com/owensgroup/BGHT/tree/main/test/cpm}{\texttt{ complete example}}). 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake\_minimum\_required(VERSION 3.8 FATAL\_ERROR)}
\DoxyCodeLine{CPMAddPackage(}
\DoxyCodeLine{  NAME bght}
\DoxyCodeLine{  GITHUB\_REPOSITORY owensgroup/BGHT}
\DoxyCodeLine{  GIT\_TAG main}
\DoxyCodeLine{  OPTIONS}
\DoxyCodeLine{     "build\_tests OFF"}
\DoxyCodeLine{     "build\_benchmarks OFF"}
\DoxyCodeLine{)}
\DoxyCodeLine{target\_link\_libraries(my\_library PRIVATE bght)}
\end{DoxyCode}
\hypertarget{index_autotoc_md3}{}\doxysubsection{A\+P\+Is}\label{index_autotoc_md3}
All the data structures follow the C++ standard hash map ({\ttfamily std\+::unordered\+\_\+map}) A\+P\+Is closely. An example A\+P\+Is for B\+C\+HT is shown below\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{template <class Key,}
\DoxyCodeLine{          class T,}
\DoxyCodeLine{          class Hash = bght::universal\_hash<Key>,}
\DoxyCodeLine{          class KeyEqual = bght::equal\_to<Key>,}
\DoxyCodeLine{          cuda::thread\_scope Scope = cuda::thread\_scope\_device,}
\DoxyCodeLine{          class Allocator = bght::cuda\_allocator<char>,}
\DoxyCodeLine{          int B = 16> class bcht;}
\end{DoxyCode}
\hypertarget{index_autotoc_md4}{}\doxysubsubsection{Member functions}\label{index_autotoc_md4}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{// Constructor}
\DoxyCodeLine{bcht(std::size\_t capacity,}
\DoxyCodeLine{     Key sentinel\_key,}
\DoxyCodeLine{     T sentinel\_value,}
\DoxyCodeLine{     Allocator const\& allocator = Allocator\{\});}
\DoxyCodeLine{// Host-\/side APIs}
\DoxyCodeLine{template <typename InputIt>}
\DoxyCodeLine{  bool insert(InputIt first, InputIt last, cudaStream\_t stream = 0);}
\DoxyCodeLine{template <typename InputIt, typename OutputIt>}
\DoxyCodeLine{  void find(InputIt first, InputIt last, OutputIt output\_begin, cudaStream\_t stream = 0);}
\DoxyCodeLine{// Device-\/side APIs}
\DoxyCodeLine{template <typename tile\_type>}
\DoxyCodeLine{\_\_device\_\_ bool insert(value\_type const\& pair, tile\_type const\& tile);}
\DoxyCodeLine{template <typename tile\_type>}
\DoxyCodeLine{\_\_device\_\_ mapped\_type find(key\_type const\& key, tile\_type const\& tile);}
\end{DoxyCode}
\hypertarget{index_autotoc_md5}{}\doxysubsection{Member types}\label{index_autotoc_md5}

\begin{DoxyCode}{0}
\DoxyCodeLine{Member type                     Definition}
\DoxyCodeLine{key\_type                        Key}
\DoxyCodeLine{mapped\_type                     T}
\DoxyCodeLine{value\_type                      bght::pair<Key, T>}
\DoxyCodeLine{allocator\_type                  Allocator}
\DoxyCodeLine{bucket\_size                     Bucket size for device-\/side APIs cooperative groups tile construction}
\end{DoxyCode}
\hypertarget{index_autotoc_md6}{}\doxysubsubsection{Example}\label{index_autotoc_md6}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{// Example using host-\/side APIs}
\DoxyCodeLine{\#include <bcht.hpp>}
\DoxyCodeLine{int main()\{}
\DoxyCodeLine{  using key\_type = uint32\_t;}
\DoxyCodeLine{  using value\_type = uint32\_t;}
\DoxyCodeLine{  using pair\_type = bght::pair<key\_type, value\_type>;}
\DoxyCodeLine{  std::size\_t capacity = 128; std::size\_t num\_keys = 64;}
\DoxyCodeLine{  key\_type invalid\_key = 0; value\_type invalid\_value = 0; // sentinel key and value}
\DoxyCodeLine{}
\DoxyCodeLine{  bght::bcht<key\_type, value\_type> table(capacity, invalid\_key, invalid\_value); //ctor}
\DoxyCodeLine{}
\DoxyCodeLine{  pair\_type* pairs; // input pairs}
\DoxyCodeLine{  // ... allocate pairs}
\DoxyCodeLine{}
\DoxyCodeLine{  bool success = table.insert(pairs, pairs + num\_keys);}
\DoxyCodeLine{  assert(success);}
\DoxyCodeLine{}
\DoxyCodeLine{  key\_type* queries;  // query keys}
\DoxyCodeLine{  value\_type* results; // query result}
\DoxyCodeLine{  // ... allocate queries and results}
\DoxyCodeLine{  table.find(queries, queries + num\_keys, results);}
\DoxyCodeLine{\}}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{// Example using device-\/side APIs}
\DoxyCodeLine{template<class HashMap>}
\DoxyCodeLine{\_\_global\_\_ void kernel(HashMap table)\{}
\DoxyCodeLine{  // construct tile}
\DoxyCodeLine{  auto block = cooperative\_groups::this\_thread\_block();}
\DoxyCodeLine{  auto tile = cooperative\_groups::tiled\_partition<HashMap::bucket\_size>(block);}
\DoxyCodeLine{  pair\_type pair\{...\};}
\DoxyCodeLine{  table.insert(pair, tile);}
\DoxyCodeLine{  pair\_type query\{..\};}
\DoxyCodeLine{  query.second = table.find(query.first, tile);}
\DoxyCodeLine{\}}
\DoxyCodeLine{int main()\{}
\DoxyCodeLine{  // Call the hash table constructor on the CPU}
\DoxyCodeLine{  bght::bcht<key\_type, value\_type> table(...);}
\DoxyCodeLine{  // Pass the hash table to a GPU kernel}
\DoxyCodeLine{  kernel<<<...>>>(table);}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{index_autotoc_md7}{}\doxysection{Requirements and limitations}\label{index_autotoc_md7}
Please create an issue if you face challenges with any of the following limitations and requirements. \hypertarget{index_autotoc_md8}{}\doxysubsection{Requirements}\label{index_autotoc_md8}

\begin{DoxyItemize}
\item C++17/\+C\+U\+DA C++17
\item N\+V\+I\+D\+IA Volta G\+PU or later microarchitectures
\item C\+Make 3.\+8 or later
\item C\+U\+DA 11.\+5 or later
\end{DoxyItemize}\hypertarget{index_autotoc_md9}{}\doxysubsection{limitations}\label{index_autotoc_md9}

\begin{DoxyItemize}
\item Currently hash tables based on cuckoo hashing do not support concurrent insertion and queries. I\+HT and P2\+B\+HT support concurrent insertions and queries.
\item Keys must be unique
\item Construction of the data structures offered {\itshape may} fail. In these scenarios, reconstructing the table using a larger capacity or a lower load factor should be considered. Our paper offers recommended hash table load factors (for uniformly distributed unsigned keys) to achieve at least a 99\% success rate (\href{https://arxiv.org/abs/2108.07232}{\texttt{ See Fig. 2}}). For example, B\+C\+HT will offer a 100\% success rate for up to 0.\+991 load factor. Please create an issue if you encounter any problems with different key distributions.
\end{DoxyItemize}\hypertarget{index_autotoc_md10}{}\doxysection{Reproducing the ar\+Xiv paper results}\label{index_autotoc_md10}
To reproduce the results, follow the following steps. You can also view our results here. If you find any mismatch (either faster or slower) between the results offered in the repository or the paper, please create an issue, and we will investigate the performance changes.\hypertarget{index_autotoc_md11}{}\doxysection{Benchmarks}\label{index_autotoc_md11}
Please check our \href{https://arxiv.org/abs/2108.07232}{\texttt{ paper}} for comprehensive analysis and benchmarks. Also, see the following steps to reproduce the results.

An additional comparison of our B\+C\+HT to {\ttfamily cuc\+Collection}\textquotesingle{}s {\ttfamily cuco\+::static\+\_\+map} is shown below. The comparison is between our B\+C\+HT with B = 16 (default configuration) and {\ttfamily cuco\+::static\+\_\+map}. Input keys (50 million pairs) are uniformly distributed unsigned keys. The benchmarking was performed on an N\+V\+I\+D\+IA Titan V G\+PU (higher is better)\+:

\hypertarget{index_autotoc_md12}{}\doxysection{Questions and bug report}\label{index_autotoc_md12}
Please create an issue. We will welcome any contributions that improve the usability and quality of our repository.\hypertarget{index_autotoc_md13}{}\doxysection{Bibtex}\label{index_autotoc_md13}

\begin{DoxyCode}{0}
\DoxyCodeLine{@inproceedings\{Awad:2023:AAI,}
\DoxyCodeLine{  title = \{Analyzing and Implementing \{GPU\} Hash Tables\},}
\DoxyCodeLine{  author = \{Muhammad A. Awad and Saman Ashkiani and Serban D.}
\DoxyCodeLine{                  Porumbescu and Mart\{\(\backslash\)'\{i\}\}n Farach-\/Colton and John}
\DoxyCodeLine{                  D. Owens\},}
\DoxyCodeLine{  booktitle = \{SIAM Symposium on Algorithmic Principles of Computer}
\DoxyCodeLine{                  Systems\},}
\DoxyCodeLine{  series = \{APOCS23\},}
\DoxyCodeLine{  year = 2023,}
\DoxyCodeLine{  month = jan,}
\DoxyCodeLine{  archiveprefix\_ = \{arXiv\},}
\DoxyCodeLine{  eprint\_ = \{2108.07232\},}
\DoxyCodeLine{  url = \{https://escholarship.org/uc/item/6cb1q6rz\}}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{index_autotoc_md14}{}\doxysection{Acknowledgments}\label{index_autotoc_md14}
The structure and organization of the repository were inspired by \href{https://github.com/nviDIA/cuCollections/}{\texttt{ N\+V\+I\+D\+IA\textquotesingle{}s cu\+Collection}} and \href{https://github.com/owensgroup/RXMesh}{\texttt{ R\+X\+Mesh}}. 